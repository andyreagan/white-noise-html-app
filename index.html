<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="description" content="Mix ambient sounds to create your perfect atmosphere. White noise, rain, ocean, fire, and more.">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" id="manifest-link">
    <title>Ambient Sounds</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            padding: 2rem;
        }
        main {
            text-align: center;
            max-width: 600px;
            width: 100%;
        }
        h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            letter-spacing: 0.1em;
        }
        .subtitle {
            color: #888;
            margin-bottom: 2.5rem;
            font-size: 1rem;
        }
        .sound-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }
        @media (max-width: 500px) {
            .sound-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        .sound-tile {
            background: linear-gradient(145deg, #2a2a4c, #1a1a3c);
            border: none;
            border-radius: 16px;
            padding: 1.25rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 4px 4px 12px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }
        .sound-tile:hover {
            transform: translateY(-2px);
            background: linear-gradient(145deg, #3a3a5c, #2a2a4c);
        }
        .sound-tile.active {
            background: linear-gradient(145deg, #3a5a4a, #2a4a3a);
            box-shadow:
                4px 4px 12px rgba(0, 0, 0, 0.3),
                0 0 20px rgba(100, 200, 150, 0.15);
        }
        .sound-tile svg {
            width: 32px;
            height: 32px;
            opacity: 0.8;
        }
        .sound-tile.active svg {
            opacity: 1;
        }
        .sound-tile .name {
            font-size: 0.85rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .sound-tile.active .name {
            color: #cfc;
        }
        .sound-tile input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            outline: none;
            margin-top: 0.25rem;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .sound-tile.active input[type="range"] {
            opacity: 1;
        }
        .sound-tile input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        .sound-tile input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: none;
        }
        .master-volume {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
        }
        .master-volume label {
            color: #888;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }
        .master-volume input[type="range"] {
            width: 150px;
            height: 6px;
            -webkit-appearance: none;
            background: #2a2a4c;
            border-radius: 3px;
            outline: none;
        }
        .master-volume input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        .master-volume input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: none;
        }
        .master-volume .value {
            color: #aaa;
            font-size: 0.85rem;
            min-width: 3em;
            font-variant-numeric: tabular-nums;
        }
    </style>
</head>
<body>
    <main>
        <h1>Ambient</h1>
        <p class="subtitle">Mix sounds to create your perfect atmosphere</p>

        <div class="sound-grid" id="soundGrid"></div>

        <div class="master-volume">
            <label>Master</label>
            <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.7" aria-label="Master volume">
            <span class="value" id="masterValue">70%</span>
        </div>
    </main>

    <script>
        let audioContext = null;
        let masterGain = null;
        const activeSounds = {};

        const sounds = [
            { id: 'white', name: 'White', icon: 'wave' },
            { id: 'pink', name: 'Pink', icon: 'wave' },
            { id: 'brown', name: 'Brown', icon: 'wave' },
            { id: 'rain', name: 'Rain', icon: 'rain' },
            { id: 'wind', name: 'Wind', icon: 'wind' },
            { id: 'stream', name: 'Stream', icon: 'water' },
            { id: 'train', name: 'Train', icon: 'train' },
            { id: 'fire', name: 'Fire', icon: 'fire' },
            { id: 'ocean', name: 'Ocean', icon: 'ocean' },
        ];

        const icons = {
            wave: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 12c1.5-3 3-4.5 4.5-4.5s3 3 4.5 4.5 3 4.5 4.5 4.5 3-1.5 4.5-4.5"/></svg>',
            rain: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 19v2m0-8v2m8 4v2m0-8v2m-4 6v2m0-8v2"/><path d="M4 13a5 5 0 0 1 5-5 4 4 0 0 1 8 1 4 4 0 0 1 3 4"/></svg>',
            wind: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"/></svg>',
            water: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 6c2-2 4-2 6 0s4 2 6 0 4-2 6 0m-18 6c2-2 4-2 6 0s4 2 6 0 4-2 6 0m-18 6c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/></svg>',
            train: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="3" width="16" height="14" rx="2"/><path d="M4 11h16M12 3v8M8 21l2-4h4l2 4M9 17h6"/><circle cx="8" cy="15" r="1" fill="currentColor"/><circle cx="16" cy="15" r="1" fill="currentColor"/></svg>',
            fire: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2c0 4-4 6-4 10a4 4 0 0 0 8 0c0-4-4-6-4-10z"/><path d="M12 18a2 2 0 0 0 2-2c0-2-2-3-2-5-0 2-2 3-2 5a2 2 0 0 0 2 2z"/></svg>',
            ocean: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 6c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/><path d="M2 12c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/><path d="M2 18c2-2 4-2 6 0s4 2 6 0 4-2 6 0"/></svg>',
        };

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = document.getElementById('masterVolume').value;
                masterGain.connect(audioContext.destination);
            }
            // Required for mobile browsers
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function saveState() {
            const state = {
                master: document.getElementById('masterVolume').value,
                sounds: {}
            };
            document.querySelectorAll('.sound-tile').forEach(tile => {
                const id = tile.dataset.sound;
                const volume = tile.querySelector('input').value;
                const active = tile.classList.contains('active');
                state.sounds[id] = { volume, active };
            });
            localStorage.setItem('ambientState', JSON.stringify(state));
        }

        function loadState() {
            try {
                const state = JSON.parse(localStorage.getItem('ambientState'));
                if (!state) return;

                document.getElementById('masterVolume').value = state.master;
                document.getElementById('masterValue').textContent = Math.round(state.master * 100) + '%';

                return state;
            } catch (e) {
                return null;
            }
        }

        function createNoiseBuffer(type) {
            const bufferSize = 2 * audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            if (type === 'white') {
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
            } else if (type === 'pink') {
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }
            } else if (type === 'brown') {
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5;
                }
            }
            return buffer;
        }

        function createRainSound() {
            const bufferSize = 4 * audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                let sample = Math.random() * 2 - 1;
                if (Math.random() < 0.002) {
                    sample *= 3;
                }
                data[i] = sample;
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            const highpass = audioContext.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.value = 400;

            const lowpass = audioContext.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = 8000;

            source.connect(highpass);
            highpass.connect(lowpass);

            return { source, output: lowpass };
        }

        function createWindSound() {
            const bufferSize = 4 * audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3;
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            const filter = audioContext.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 300;
            filter.Q.value = 0.5;

            const lfo = audioContext.createOscillator();
            lfo.frequency.value = 0.2;
            const lfoGain = audioContext.createGain();
            lfoGain.gain.value = 150;
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            lfo.start();

            source.connect(filter);

            return { source, output: filter, lfo };
        }

        function createStreamSound() {
            const bufferSize = 4 * audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
                if (Math.random() < 0.01) {
                    data[i] *= 2;
                }
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            const bandpass = audioContext.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.frequency.value = 1000;
            bandpass.Q.value = 0.3;

            const lowpass = audioContext.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = 4000;

            source.connect(bandpass);
            bandpass.connect(lowpass);

            return { source, output: lowpass };
        }

        function createTrainSound() {
            // Train rhythm: "clickety-clack" pattern ~1.5 seconds per cycle
            const cycleDuration = 1.5;
            const bufferSize = Math.floor(cycleDuration * audioContext.sampleRate);
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            // Base rumble (brown noise)
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 2;
            }

            // Add rhythmic bumps: da-dum ... da-dum pattern
            // Two quick hits then pause
            const bumpDuration = Math.floor(0.08 * audioContext.sampleRate);
            const bumps = [
                { start: 0.0, intensity: 1.0 },
                { start: 0.15, intensity: 0.8 },
                { start: 0.75, intensity: 0.95 },
                { start: 0.90, intensity: 0.75 },
            ];

            for (const bump of bumps) {
                const startSample = Math.floor(bump.start * audioContext.sampleRate);
                for (let i = 0; i < bumpDuration && startSample + i < bufferSize; i++) {
                    // Envelope: quick attack, longer decay
                    const env = Math.exp(-i / (bumpDuration * 0.3)) * bump.intensity;
                    // Low frequency thump
                    const thump = Math.sin(i * 0.015) * env * 0.8;
                    data[startSample + i] += thump;
                }
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            // Low pass to keep it rumbly
            const lowpass = audioContext.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = 300;

            source.connect(lowpass);

            return { source, output: lowpass };
        }

        function createFireSound() {
            const bufferSize = 4 * audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            // Crackling fire: base rumble + random pops
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                // Brown noise base
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 2;

                // Random crackles
                if (Math.random() < 0.001) {
                    const crackleLength = Math.floor(Math.random() * 800 + 200);
                    const intensity = Math.random() * 0.5 + 0.3;
                    for (let j = 0; j < crackleLength && i + j < bufferSize; j++) {
                        const env = Math.exp(-j / (crackleLength * 0.2));
                        data[i + j] += (Math.random() * 2 - 1) * env * intensity;
                    }
                }
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            const bandpass = audioContext.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.frequency.value = 500;
            bandpass.Q.value = 0.5;

            source.connect(bandpass);

            return { source, output: bandpass };
        }

        function createOceanSound() {
            // Ocean waves with slow rhythm ~8 seconds per wave
            const cycleDuration = 8;
            const bufferSize = Math.floor(cycleDuration * audioContext.sampleRate);
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);

            // Pink noise base
            let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                const pink = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                b6 = white * 0.115926;

                // Wave envelope: slow rise, crash, long fade
                const t = i / bufferSize;
                const wave = Math.pow(Math.sin(t * Math.PI), 0.5);
                // Add some crash at the peak
                const crash = t > 0.4 && t < 0.6 ? Math.exp(-Math.pow((t - 0.5) * 10, 2)) * 0.5 : 0;

                data[i] = pink * (wave + crash) * 1.5;
            }

            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            const lowpass = audioContext.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = 1500;

            source.connect(lowpass);

            return { source, output: lowpass };
        }

        function startSound(id) {
            initAudio();

            const tile = document.querySelector(`[data-sound="${id}"]`);
            const volumeSlider = tile.querySelector('input');

            const gain = audioContext.createGain();
            gain.gain.value = parseFloat(volumeSlider.value);
            gain.connect(masterGain);

            let source, extras = {};

            if (id === 'white' || id === 'pink' || id === 'brown') {
                source = audioContext.createBufferSource();
                source.buffer = createNoiseBuffer(id);
                source.loop = true;
                source.connect(gain);
            } else if (id === 'rain') {
                const rain = createRainSound();
                source = rain.source;
                rain.output.connect(gain);
            } else if (id === 'wind') {
                const wind = createWindSound();
                source = wind.source;
                wind.output.connect(gain);
                extras.lfo = wind.lfo;
            } else if (id === 'stream') {
                const stream = createStreamSound();
                source = stream.source;
                stream.output.connect(gain);
            } else if (id === 'train') {
                const train = createTrainSound();
                source = train.source;
                train.output.connect(gain);
            } else if (id === 'fire') {
                const fire = createFireSound();
                source = fire.source;
                fire.output.connect(gain);
            } else if (id === 'ocean') {
                const ocean = createOceanSound();
                source = ocean.source;
                ocean.output.connect(gain);
            }

            source.start();
            activeSounds[id] = { source, gain, ...extras };
        }

        function stopSound(id) {
            if (activeSounds[id]) {
                activeSounds[id].source.stop();
                activeSounds[id].source.disconnect();
                activeSounds[id].gain.disconnect();
                if (activeSounds[id].lfo) {
                    activeSounds[id].lfo.stop();
                    activeSounds[id].lfo.disconnect();
                }
                delete activeSounds[id];
            }
        }

        function toggleSound(id) {
            const tile = document.querySelector(`[data-sound="${id}"]`);
            if (activeSounds[id]) {
                stopSound(id);
                tile.classList.remove('active');
            } else {
                startSound(id);
                tile.classList.add('active');
            }
            saveState();
        }

        function updateSoundVolume(id, value) {
            if (activeSounds[id]) {
                activeSounds[id].gain.gain.value = value;
            }
        }

        // Load saved state
        const savedState = loadState();

        // Build UI
        const grid = document.getElementById('soundGrid');
        sounds.forEach(sound => {
            const tile = document.createElement('button');
            tile.className = 'sound-tile';
            tile.dataset.sound = sound.id;
            tile.setAttribute('aria-label', `Toggle ${sound.name} sound`);
            tile.setAttribute('aria-pressed', 'false');

            const savedVolume = savedState?.sounds?.[sound.id]?.volume ?? 0.5;

            tile.innerHTML = `
                ${icons[sound.icon]}
                <span class="name">${sound.name}</span>
                <input type="range" min="0" max="1" step="0.01" value="${savedVolume}" aria-label="${sound.name} volume">
            `;

            tile.addEventListener('click', (e) => {
                if (e.target.type !== 'range') {
                    toggleSound(sound.id);
                    tile.setAttribute('aria-pressed', tile.classList.contains('active'));
                }
            });

            tile.querySelector('input').addEventListener('input', (e) => {
                e.stopPropagation();
                updateSoundVolume(sound.id, e.target.value);
                saveState();
            });

            grid.appendChild(tile);
        });

        // Master volume
        const masterSlider = document.getElementById('masterVolume');
        const masterValue = document.getElementById('masterValue');

        masterSlider.addEventListener('input', () => {
            masterValue.textContent = Math.round(masterSlider.value * 100) + '%';
            if (masterGain) {
                masterGain.gain.value = masterSlider.value;
            }
            saveState();
        });

        // Generate manifest dynamically
        const manifest = {
            name: 'Ambient Sounds',
            short_name: 'Ambient',
            start_url: location.href,
            display: 'standalone',
            background_color: '#1a1a2e',
            theme_color: '#1a1a2e',
            icons: [{
                src: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%231a1a2e' width='100' height='100' rx='20'/><circle cx='50' cy='45' r='25' fill='none' stroke='white' stroke-width='4'/><ellipse cx='50' cy='45' rx='10' ry='12' fill='white'/><path d='M25 45 Q25 75 50 75 Q75 75 75 45' fill='none' stroke='white' stroke-width='4'/></svg>",
                sizes: '512x512',
                type: 'image/svg+xml',
                purpose: 'any'
            }]
        };
        const manifestBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
        document.getElementById('manifest-link').href = URL.createObjectURL(manifestBlob);

    </script>
</body>
</html>
